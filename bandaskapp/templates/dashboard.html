{% extends 'base.html' %}

{% block content %}
<div class="row h-100">
    <!-- Left Side - Heat Tank Visualization (50% width) -->
    <div class="col-6 h-100">
        <div class="heat-tank">
            
            <!-- Check if any sensors are enabled -->
            {% if not thermometers %}
            <div class="temperature-field" style="text-align: center; padding: 40px;">
                <h4 style="color: #ff4444;">No Temperature Sensors Enabled</h4>
                <p style="color: #cccccc;">All temperature sensors are currently disabled in the configuration.</p>
                <p style="color: #cccccc;">Check settings.py to enable sensors or contact administrator.</p>
            </div>
            {% else %}
            
            <!-- Dynamic Thermometer Fields -->
            {% for thermometer in thermometers %}
            {% if thermometer.label != 'NONE' %}
            <div class="temperature-field {% if forloop.first %}top{% elif forloop.counter <= 3 %}heating{% else %}bottom{% endif %}">
                <div class="row">
                    <div class="col-8 text-end">
                        <div class="mini-graph" id="mini-graph-{{ forloop.counter0 }}">
                            <div class="mini-graph-container">
                                <canvas width="100%" height="100%"></canvas>
                                <div class="time-label" id="time-label-{{ forloop.counter0 }}"></div>
                            </div>
                        </div>
                    </div>
                    <div class="col-4">
                        <h5 style="color: {{ thermometer.color }}; font-size: 1rem; margin-bottom: 5px;">{{ thermometer.label }}</h5>
                        <div class="temperature-display">
                            <span id="temp-{{ forloop.counter0 }}">{{ thermometer.temp_key|default:0|floatformat:1 }}</span>°C
                        </div>
                        <small class="text-muted" style="font-size: 0.8rem;">Sensor: 
                            <span id="sensor-status-{{ forloop.counter0 }}" class="{% if thermometer.online_key %}status-on{% else %}sensor-offline{% endif %}">{% if thermometer.online_key %}Online{% else %}Offline{% endif %}</span>
                        </small>
                    </div>
                </div>
            </div>
            {% endif %}
            {% endfor %}
            
            {% endif %}
        </div>
    </div>
    
    <!-- Right Side - Control Panel -->
    <div class="col-6">
        <div class="control-panel">
            <!-- Control Buttons -->
            <div class="row mb-2">
                <div class="col-6 mb-1">
                    <button id="mode-toggle-btn" class="btn {% if control_mode == 'automatic' %}btn-success{% else %}btn-danger{% endif %} btn-control-mode w-100" onclick="toggleMode()">
                        <strong id="mode-toggle-text" style="font-size: 0.9rem;">Mode {{ control_mode|upper }}</strong>
                    </button>
                </div>
                <div class="col-6 mb-1">
                    <button id="furnace-toggle-btn" class="btn {% if furnace_running %}btn-success{% else %}btn-danger{% endif %} btn-control-furnace w-100 btn-timer-container" onclick="toggleFurnace()">
                        <div class="btn-text">
                            <strong id="furnace-toggle-text" style="font-size: 0.9rem;">Furnace {% if furnace_running %}ON{% else %}OFF{% endif %}</strong>
                        </div>
                        <div class="timer-display btn-timer-right" id="furnace-timer">00:00</div>
                    </button>
                </div>
                <div class="col-6 mb-1">
                    <button id="winter-toggle-btn" class="btn {% if winter_regime_state == 'automatic' %}btn-success{% elif winter_regime_state == 'off' %}btn-danger{% else %}btn-primary{% endif %} btn-control-heating w-100" onclick="cycleWinterRegime()">
                        <strong id="winter-toggle-text" style="font-size: 0.9rem;">Winter {{ winter_regime_state|upper }}</strong>
                    </button>
                </div>
                <div class="col-6 mb-1">
                    <button id="pump-toggle-btn" class="btn btn-danger btn-control-pump w-100 btn-timer-container" onclick="togglePump()">
                        <div class="btn-text">
                            <strong id="pump-toggle-text" style="font-size: 0.9rem;">Pump {% if pump_running %}ON{% else %}OFF{% endif %}</strong>
                        </div>
                        <div class="timer-display btn-timer-right" id="pump-timer">00:00</div>
                    </button>
                </div>
            </div>
            
            <!-- Temperature Thresholds -->
            <hr style="border-color: #444444;">
            <div class="row temperature-thresholds">
                <div class="col-12 mb-1">
                    <h6 style="color: #00ff00; font-size: 0.9rem;">Temperature Thresholds</h6>
                </div>
                <div class="d-flex align-items-start">
                    <!-- Left side: Input controls -->
                    <div class="flex-grow-1">
                        <div class="row">
                            <div class="col-6 mb-1">
                                <label for="dhw-low" class="form-label" style="font-size: 0.8rem;">DHW Low (°C):</label>
                                <div class="d-flex align-items-center">
                                    <button class="btn btn-outline-warning btn-sm me-1" onclick="adjustThreshold('dhw-low', -1)" style="min-width: 40px; height: 35px; font-size: 1rem;">-1</button>
                                    <input type="number" class="form-control" id="dhw-low" value="{{ dhw_temp_low|floatformat:1 }}" min="20" max="70" step="0.5" style="text-align: center; font-size: 0.9rem; padding: 4px;">
                                    <button class="btn btn-outline-warning btn-sm ms-1" onclick="adjustThreshold('dhw-low', 1)" style="min-width: 40px; height: 35px; font-size: 1rem;">+1</button>
                                </div>
                            </div>
                            <div class="col-6 mb-1">
                                <label for="dhw-high" class="form-label" style="font-size: 0.8rem;">DHW High (°C):</label>
                                <div class="d-flex align-items-center">
                                    <button class="btn btn-outline-warning btn-sm me-1" onclick="adjustThreshold('dhw-high', -1)" style="min-width: 40px; height: 35px; font-size: 1rem;">-1</button>
                                    <input type="number" class="form-control" id="dhw-high" value="{{ dhw_temp_high|floatformat:1 }}" min="30" max="80" step="0.5" style="text-align: center; font-size: 0.9rem; padding: 4px;">
                                    <button class="btn btn-outline-warning btn-sm ms-1" onclick="adjustThreshold('dhw-high', 1)" style="min-width: 40px; height: 35px; font-size: 1rem;">+1</button>
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-6 mb-1">
                                <label for="hhw-low" class="form-label" style="font-size: 0.8rem;">HHW Low (°C):</label>
                                <div class="d-flex align-items-center">
                                    <button class="btn btn-outline-warning btn-sm me-1" onclick="adjustThreshold('hhw-low', -1)" style="min-width: 40px; height: 35px; font-size: 1rem;">-1</button>
                                    <input type="number" class="form-control" id="hhw-low" value="{{ hhw_temp_low|floatformat:1 }}" min="20" max="70" step="0.5" style="text-align: center; font-size: 0.9rem; padding: 4px;">
                                    <button class="btn btn-outline-warning btn-sm ms-1" onclick="adjustThreshold('hhw-low', 1)" style="min-width: 40px; height: 35px; font-size: 1rem;">+1</button>
                                </div>
                            </div>
                            <div class="col-6 mb-1">
                                <label for="hhw-high" class="form-label" style="font-size: 0.8rem;">HHW High (°C):</label>
                                <div class="d-flex align-items-center">
                                    <button class="btn btn-outline-warning btn-sm me-1" onclick="adjustThreshold('hhw-high', -1)" style="min-width: 40px; height: 35px; font-size: 1rem;">-1</button>
                                    <input type="number" class="form-control" id="hhw-high" value="{{ hhw_temp_high|floatformat:1 }}" min="30" max="80" step="0.5" style="text-align: center; font-size: 0.9rem; padding: 4px;">
                                    <button class="btn btn-outline-warning btn-sm ms-1" onclick="adjustThreshold('hhw-high', 1)" style="min-width: 40px; height: 35px; font-size: 1rem;">+1</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Right side: Update button -->
                    <div class="ms-2 d-flex align-items-center">
                        <button class="btn btn-info btn_update_thresholds" onclick="updateThresholds()" style="height: 140px; width: 40px; font-size: 0.9rem;">
                            <span>Update</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<!-- System Status Alert -->
{% if not api_connected %}
<div class="alert alert-danger api-disconnected" role="alert">
    <strong>⚠️ API Connection Lost!</strong> Cannot communicate with hardware. 
    Last successful connection: {{ last_reading|default:"Unknown" }}
</div>
{% endif %}
{% endblock %}

{% block extra_js %}
<script>
    // ===== DASHBOARD LOGGING SYSTEM =====
    // Configure logging level: 'debug', 'info', 'warn', 'error', or 'none'
    const DASHBOARD_LOG_LEVEL = 'none'; // Change to 'debug' for development, 'none' for production
    
    const DASHBOARD_LOG_LEVELS = {
        'none': 0,
        'error': 1,
        'warn': 2,
        'info': 3,
        'debug': 4
    };
    
    const dashboardCurrentLogLevel = DASHBOARD_LOG_LEVELS[DASHBOARD_LOG_LEVEL] || DASHBOARD_LOG_LEVELS['info'];
    
    function dashboardLog(level, message, ...args) {
        const levelNum = DASHBOARD_LOG_LEVELS[level] || 0;
        if (levelNum <= dashboardCurrentLogLevel && levelNum > 0) {
            const timestamp = new Date().toLocaleTimeString('en-GB', { hour12: false });
            const prefix = `[${timestamp}] [DASHBOARD-${level.toUpperCase()}]`;
            
            switch(level) {
                case 'error':
                    console.error(prefix, message, ...args);
                    break;
                case 'warn':
                    console.warn(prefix, message, ...args);
                    break;
                case 'info':
                    console.info(prefix, message, ...args);
                    break;
                case 'debug':
                    console.log(prefix, message, ...args);
                    break;
            }
        }
    }
    
    // Convenience functions
    function debug(message, ...args) { dashboardLog('debug', message, ...args); }
    function info(message, ...args) { dashboardLog('info', message, ...args); }
    function warn(message, ...args) { dashboardLog('warn', message, ...args); }
    function error(message, ...args) { dashboardLog('error', message, ...args); }
    
    // Log system initialization
    info('BandaskApp dashboard logging system initialized with level:', DASHBOARD_LOG_LEVEL);
    
    // ===== END DASHBOARD LOGGING SYSTEM =====
    
    // Global storage for mini-graph data to persist across tab switches
    // miniGraphData is declared in base.html
    
    // Enhanced data persistence using localStorage
    const MINI_GRAPH_STORAGE_KEY = 'bandaskapp_mini_graph_data';
    const MINI_GRAPH_TIMESTAMP_KEY = 'bandaskapp_mini_graph_timestamp';
    
    // Function to save mini-graph data to localStorage
    function saveMiniGraphData() {
        try {
            const dataToSave = {};
            Object.keys(miniGraphData).forEach(key => {
                if (miniGraphData[key] && miniGraphData[key].data) {
                    dataToSave[key] = {
                        data: miniGraphData[key].data,
                        zoomLevel: miniGraphData[key].getZoomLevel ? miniGraphData[key].getZoomLevel() : 0
                    };
                }
            });
            
            localStorage.setItem(MINI_GRAPH_STORAGE_KEY, JSON.stringify(dataToSave));
            localStorage.setItem(MINI_GRAPH_TIMESTAMP_KEY, Date.now().toString());
            debug('Mini-graph data saved to localStorage:', dataToSave);
        } catch (error) {
            error('Error saving mini-graph data to localStorage:', error);
        }
    }
    
    // Function to load mini-graph data from localStorage
    function loadMiniGraphData() {
        try {
            const savedData = localStorage.getItem(MINI_GRAPH_STORAGE_KEY);
            const timestamp = localStorage.getItem(MINI_GRAPH_TIMESTAMP_KEY);
            
            if (savedData && timestamp) {
                const parsedData = JSON.parse(savedData);
                const dataAge = Date.now() - parseInt(timestamp);
                
                // Only restore data if it's less than 1 hour old
                if (dataAge < 3600000) {
                    debug('Restoring mini-graph data from localStorage:', parsedData);
                    return parsedData;
                } else {
                    debug('Mini-graph data is too old, clearing localStorage');
                    localStorage.removeItem(MINI_GRAPH_STORAGE_KEY);
                    localStorage.removeItem(MINI_GRAPH_TIMESTAMP_KEY);
                }
            }
        } catch (error) {
            error('Error loading mini-graph data from localStorage:', error);
        }
        return {};
    }
    
    // Function to restore mini-graph data to existing graphs
    function restoreMiniGraphData(savedData) {
        Object.keys(savedData).forEach(key => {
            if (miniGraphData[key] && savedData[key].data) {
                debug(`Restoring ${key} mini-graph with ${savedData[key].data.length} data points`);
                
                // Restore data
                miniGraphData[key].data.length = 0; // Clear existing data
                miniGraphData[key].data.push(...savedData[key].data);
                
                // Restore zoom level if possible
                if (savedData[key].zoomLevel !== undefined && miniGraphData[key].setZoomLevel) {
                    miniGraphData[key].setZoomLevel(savedData[key].zoomLevel);
                }
                
                // Redraw the graph immediately
                if (miniGraphData[key].drawGraph) {
                    miniGraphData[key].drawGraph();
                }
                
                // Force resize and redraw to ensure proper rendering
                if (miniGraphData[key].resizeCanvas) {
                    setTimeout(() => {
                        miniGraphData[key].resizeCanvas();
                    }, 50);
                }
            }
        });
    }
    
    // Function to manually force render all mini-graphs (for debugging)
    window.forceRenderAllMiniGraphs = function() {
        debug('Manual force render requested');
        Object.keys(miniGraphData).forEach(key => {
            if (miniGraphData[key]) {
                if (miniGraphData[key].resizeCanvas) {
                    miniGraphData[key].resizeCanvas();
                }
                if (miniGraphData[key].drawGraph) {
                    miniGraphData[key].drawGraph();
                }
            }
        });
    };
    
    // Function to create a mini-graph
    function createMiniGraph(canvasId, color, baseOffset = 0) {
        const canvasContainer = document.getElementById(canvasId);
        if (!canvasContainer) {
            error(`Canvas container ${canvasId} not found`);
            return null;
        }
        const canvas = canvasContainer.querySelector('canvas');
        if (!canvas) {
            error(`Canvas element not found in container ${canvasId}`);
            return null;
        }
        const ctx = canvas.getContext('2d');
        if (!ctx) {
            error(`Could not get 2D context for canvas in ${canvasId}`);
            return null;
        }
        
        debug(`Successfully created mini graph for ${canvasId}, container:`, canvasContainer, 'canvas:', canvas, 'ctx:', ctx);
        debug(`${canvasId} initial canvas size: ${canvas.width}x${canvas.height}`);

        // Initialize or retrieve data from global storage
        // Extract the key from canvasId (remove 'mini-graph-' prefix)
        const key = canvasId.replace('mini-graph-', '');
        if (!miniGraphData[key]) {
            miniGraphData[key] = [];
        }
        const data = miniGraphData[key];
        
        debug(`${canvasId} initialized with ${data.length} data points`);
        
        const ZOOM_LEVELS = [1, 2, 4, 8, 16, 32, 64, 128];
        let currentZoomIndex = 0;

        // Maximum data buffer size: 150,000 data points for production
        const MAX_BUFFER_SIZE = 150000;

        function getMaxDataPoints() {
            // Always maintain the full buffer size, regardless of canvas width
            return MAX_BUFFER_SIZE;
        }

        // Make canvas responsive to fit its container
        function resizeCanvas() {
            const col8Element = canvasContainer.closest('.col-8');
            if (col8Element) {
                const colWidth = col8Element.offsetWidth;
                const temperatureField = canvasContainer.closest('.temperature-field');
                const col4Element = temperatureField.querySelector('.col-4');
                
                if (col4Element) {
                    // Calculate height to match col-4 content: h5 + temperature-display + text-muted
                    const h5Height = col4Element.querySelector('h5').offsetHeight;
                    const tempDisplayHeight = col4Element.querySelector('.temperature-display').offsetHeight;
                    const smallHeight = col4Element.querySelector('small').offsetHeight;
                    
                    // Total height should match the col-4 content exactly
                    const contentHeight = h5Height + tempDisplayHeight + smallHeight;
                    
                    // Set canvas size to match the col-8 width and the content height
                    canvas.width = colWidth - 8; // Subtract padding from col-8
                    canvas.height = contentHeight; // Match col-4 height exactly
                    
                    debug(`Canvas resized to ${canvas.width}x${canvas.height} for ${canvasId} (col-8 width: ${colWidth}, h5: ${h5Height}, temp: ${tempDisplayHeight}, small: ${smallHeight}, total: ${contentHeight})`);
                    
                    // Immediately redraw the graph with existing data after resize
                    if (data.length > 0) {
                        debug(`Redrawing ${canvasId} with ${data.length} data points after resize`);
                        drawGraph();
                    }
                } else {
                    // Fallback: use a reasonable height
                    canvas.width = colWidth - 8;
                    canvas.height = 80; // Default height
                    debug(`Canvas resized to ${canvas.width}x${canvas.height} for ${canvasId} (fallback height)`);
                    
                    // Immediately redraw the graph with existing data after resize
                    if (data.length > 0) {
                        debug(`Redrawing ${canvasId} with ${data.length} data points after resize (fallback)`);
                        drawGraph();
                    }
                }
            } else {
                // Fallback to container dimensions
                const computedStyle = window.getComputedStyle(canvasContainer);
                const width = parseInt(computedStyle.width) - 4;
                const height = parseInt(computedStyle.height) - 4;
                
                canvas.width = width;
                canvas.height = height;
                
                debug(`Canvas resized to ${canvas.width}x${canvas.height} for ${canvasId} (fallback)`);
                
                // Immediately redraw the graph with existing data after resize
                if (data.length > 0) {
                    debug(`Redrawing ${canvasId} with ${data.length} data points after resize (container fallback)`);
                    drawGraph();
                }
            }
        }
        resizeCanvas();
        info(`${canvasId} mini-graph created successfully`);
        window.addEventListener('resize', resizeCanvas);

        // Draw the scrolling real-time graph
        function drawGraph() {
            debug(`drawGraph called for ${canvasId}, data length: ${data.length}, zoom: ${ZOOM_LEVELS[currentZoomIndex]}x`); // Debug log
            
            // Check if canvas dimensions are valid
            if (canvas.width <= 0 || canvas.height <= 0) {
                error(`${canvasId} invalid canvas dimensions: ${canvas.width}x${canvas.height}, skipping draw`);
                return;
            }
            
            // Clear canvas completely
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Fill background
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw border
            ctx.strokeStyle = '#444444';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
            
            if (data.length === 0) {
                // Draw empty state indicator
                ctx.fillStyle = '#666666';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No data yet', canvas.width / 2, canvas.height / 2);
                warn(`${canvasId} no data, drawing empty state`);
                return;
            }
            
            // Calculate visible data points based on zoom level FIRST
            const zoomLevel = ZOOM_LEVELS[currentZoomIndex];
            const visibleWidth = canvas.width;
            const dataPointsPerPixel = zoomLevel;
            // Get the most recent data points that fit in the visible area (newest data on right)
            const maxVisiblePoints = Math.floor(visibleWidth * dataPointsPerPixel);
            // Always start from the end of the data array to show the most recent data
            // This ensures newest data is always anchored to the right side
            const startIndex = Math.max(0, data.length - maxVisiblePoints);
            const visibleData = data.slice(startIndex);
            
            debug(`${canvasId} debug: data.length=${data.length}, visibleData.length=${visibleData.length}, zoomLevel=${zoomLevel}, canvas.width=${canvas.width}`);
            if (visibleData.length > 0) {
                debug(`${canvasId} debug: visibleData sample:`, visibleData.slice(0, 5));
            }
            
            // Calculate dynamic Y-axis range with 5% padding
            let minY, maxY, yRange;
            try {
                if (visibleData.length === 0) {
                    // Use default range if no data
                    minY = 15;
                    maxY = 95;
                    yRange = maxY - minY;
                } else if (visibleData.length === 1) {
                    // Single data point - create range around it
                    const singleValue = visibleData[0];
                    minY = Math.max(0, singleValue - 2.5);
                    maxY = Math.min(100, singleValue + 2.5);
                    yRange = maxY - minY;
                } else {
                    // Multiple data points - calculate range with 10% padding
                    const dataRange = Math.max(...visibleData) - Math.min(...visibleData);
                    minY = Math.min(...visibleData) - (dataRange * 0.10);
                    maxY = Math.max(...visibleData) + (dataRange * 0.10);
                    
                    // Ensure minimum range of 5°C to prevent extreme scaling
                    const minRange = 5;
                    if ((maxY - minY) < minRange) {
                        const center = (minY + maxY) / 2;
                        minY = center - (minRange / 2);
                        maxY = center + (minRange / 2);
                    }
                    
                    // Ensure reasonable bounds (0-100°C for temperature sensors)
                    minY = Math.max(0, minY);
                    maxY = Math.min(100, maxY);
                    yRange = maxY - minY;
                    
                    // Debug logging for auto-scaling
                    debug(`${canvasId} auto-scaling: data range ${Math.min(...visibleData).toFixed(1)}-${Math.max(...visibleData).toFixed(1)}°C, Y-axis ${minY.toFixed(1)}-${maxY.toFixed(1)}°C (${yRange.toFixed(1)}°C total) - 10% padding`);
                }
            } catch (error) {
                // Fallback to default range if calculation fails
                error(`${canvasId} auto-scaling error:`, error);
                minY = 15;
                maxY = 95;
                yRange = maxY - minY;
            }
            
            debug(`${canvasId} drawing: ${visibleData.length} visible points (startIndex: ${startIndex}, total: ${data.length})`);
            if (visibleData.length > 0) {
                debug(`${canvasId} data range: ${visibleData[0]}°C (oldest, left) to ${visibleData[visibleData.length-1]}°C (newest, right)`);
            }
            
            if (visibleData.length < 2) {
                // Draw single point or empty state
                if (visibleData.length === 1) {
                    const y = canvas.height - ((visibleData[0] - minY) / yRange) * canvas.height;
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    // Position single point on the right side to match the new anchoring logic
                    ctx.arc(canvas.width - 5, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
                return;
            }
            
            // Draw grid lines
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 0.5;
            
            // Dynamic horizontal grid lines based on current Y-axis range
            const gridStep = Math.ceil(yRange / 8); // Divide range into ~8 sections
            for (let temp = Math.ceil(minY); temp <= Math.floor(maxY); temp += gridStep) {
                const y = canvas.height - ((temp - minY) / yRange) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw temperature line from left to right (oldest data on left, newest data on right)
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            let firstPoint = true;
            for (let i = 0; i < visibleData.length; i++) {
                // X position: left to right (oldest data on left, newest data on right)
                // Calculate X so that newest data (last in visibleData) is anchored to the right boundary
                // When zooming out, we want to see more history to the left while keeping newest data on the right
                const x = canvas.width - ((visibleData.length - 1 - i) / dataPointsPerPixel);
                const y = canvas.height - ((visibleData[i] - minY) / yRange) * canvas.height;
                
                if (firstPoint) {
                    ctx.moveTo(x, y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            
            // Draw data points from left to right
            ctx.fillStyle = color;
            for (let i = 0; i < visibleData.length; i++) {
                // Use the same X positioning logic as the line drawing
                const x = canvas.width - ((visibleData.length - 1 - i) / dataPointsPerPixel);
                const y = canvas.height - ((visibleData[i] - minY) / yRange) * canvas.height;
                
                ctx.beginPath();
                ctx.arc(x, y, 1.5, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // Draw zoom indicator (top right)
            ctx.fillStyle = '#666666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`${ZOOM_LEVELS[currentZoomIndex]}x`, canvas.width - 5, 15);
            
            // Draw Y-axis scale info (top left and bottom left)
            ctx.fillStyle = '#ffffff';
            ctx.font = '8px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`${maxY.toFixed(1)}°C`, 5, 10);
            ctx.fillText(`${minY.toFixed(1)}°C`, 5, canvas.height - 5);
            
            // Update time duration indicator below the graph
            const samplingRate = 5; // 5 seconds per sample
            const totalDataPoints = visibleData.length;
            const totalSeconds = totalDataPoints * samplingRate;
            const totalHours = totalSeconds / 3600;
            
            // Format time duration
            let timeLabel;
            if (totalHours >= 1) {
                timeLabel = `${totalHours.toFixed(1)}h`;
            } else {
                const totalMinutes = totalSeconds / 60;
                timeLabel = `${totalMinutes.toFixed(0)}m`;
            }
            
            // Update the time label element
            const timeLabelElement = document.getElementById(`time-label-${key}`);
            if (timeLabelElement) {
                timeLabelElement.textContent = timeLabel;
            }
        }

        // Draw the graph immediately after creation
        setTimeout(() => {
            drawGraph();
        }, 100);

        function updateData(temperature) {
            // Add new data point to the right (end of array) - will appear on right side of graph
            data.push(temperature);
            
            // Implement FIFO: if buffer is full, remove oldest data from the left (beginning)
            if (data.length > MAX_BUFFER_SIZE) {
                const removedValue = data.shift(); // Remove first element (oldest data)
                debug(`${canvasId} FIFO: removed oldest value ${removedValue}°C, buffer now ${data.length}/${MAX_BUFFER_SIZE}`);
            }
            
            // Debug: Log buffer status occasionally (every 1000 updates)
            if (data.length % 1000 === 0) {
                debug(`${canvasId} buffer: ${data.length}/${MAX_BUFFER_SIZE} points (${(data.length/MAX_BUFFER_SIZE*100).toFixed(1)}% full)`);
            }
            
            drawGraph();
            
            // Auto-save data to localStorage after each update
            setTimeout(saveMiniGraphData, 100);
        }

        function clearData() {
            data.length = 0;
            drawGraph();
        }

        function zoomOut() {
            if (currentZoomIndex < ZOOM_LEVELS.length - 1) {
                currentZoomIndex++;
                debug(`Zoomed out to ${ZOOM_LEVELS[currentZoomIndex]}x for ${canvasId}`);
                drawGraph();
            }
        }

        function zoomIn() {
            if (currentZoomIndex > 0) {
                currentZoomIndex--;
                debug(`Zoomed in to ${ZOOM_LEVELS[currentZoomIndex]}x for ${canvasId}`);
                drawGraph();
            }
        }

        canvas.addEventListener('click', function(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const canvasWidth = canvas.width;
            if (x < canvasWidth / 2) {
                zoomOut();
            } else {
                zoomIn();
            }
        });

        canvas.addEventListener('touchstart', function(event) {
            event.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = event.touches[0];
            const x = touch.clientX - rect.left;
            const canvasWidth = canvas.width;
            if (x < canvasWidth / 2) {
                zoomOut();
            } else {
                zoomIn();
            }
        });

        return {
            canvas: canvas,
            data: data,
            updateData: updateData,
            clearData: clearData,
            zoomIn: zoomIn,
            zoomOut: zoomOut,
            getZoomLevel: () => ZOOM_LEVELS[currentZoomIndex],
            setZoomLevel: function(level) {
                const index = ZOOM_LEVELS.indexOf(level);
                if (index !== -1) {
                    currentZoomIndex = index;
                    debug(`Zoom level set to ${level}x for ${canvasId}`);
                    drawGraph();
                }
            },
            drawGraph: drawGraph, // Expose drawGraph for persistence
            drawTestPattern: function() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Test: ${canvasId}`, canvas.width / 2, canvas.height / 2);
            }
        };
    }
    
    // Initialize mini graphs
    document.addEventListener('DOMContentLoaded', function() {
        debug('DOMContentLoaded event fired'); // Debug log
        
        // Load existing mini-graph data from localStorage
        const savedData = loadMiniGraphData();
        if (Object.keys(savedData).length > 0) {
            debug('Restoring mini-graph data from localStorage:', savedData);
            restoreMiniGraphData(savedData);
        } else {
            debug('No existing mini-graph data found in localStorage, starting fresh.');
        }
        
        // Check if canvas elements exist and create a dynamic list based on enabled sensors
        const canvasElements = {};
        
        // Dynamically detect canvas elements based on thermometer configuration
        const maxThermometers = 10; // Reasonable upper limit
        for (let i = 0; i < maxThermometers; i++) {
            const canvasElement = document.getElementById(`mini-graph-${i}`);
            if (canvasElement) {
                canvasElements[`thermometer-${i}`] = canvasElement;
            }
        }
        
        debug('Canvas elements found:', canvasElements); // Debug log
        
        // Only create mini graphs for elements that exist AND don't already exist
        Object.keys(canvasElements).forEach(key => {
            if (canvasElements[key] && !miniGraphData[key]) {
                debug(`Creating mini graph for ${key}`); // Debug log
                let miniGraph = null;
                
                // Extract index from key (e.g., 'thermometer-0' -> 0)
                const index = parseInt(key.split('-')[1]);
                
                // Create mini graph with appropriate color and offset
                if (index === 0) {
                    miniGraph = createMiniGraph(`mini-graph-${index}`, '#ff6b6b', 0);
                } else if (index <= 2) {
                    const offset = index === 1 ? -5 : -10;
                    miniGraph = createMiniGraph(`mini-graph-${index}`, '#ffa500', offset);
                } else {
                    const offset = index === 3 ? -15 : -20;
                    miniGraph = createMiniGraph(`mini-graph-${index}`, '#4ecdc4', offset);
                }
                
                if (miniGraph) {
                    miniGraphData[key] = miniGraph; // Store in global data object
                    info(`Mini graph for ${key} created successfully`);
                    
                    // Restore data if available
                    if (savedData[key] && savedData[key].data) {
                        info(`Restoring ${key} data: ${savedData[key].data.length} points`);
                        miniGraph.data.length = 0;
                        miniGraph.data.push(...savedData[key].data);
                        
                        if (savedData[key].zoomLevel !== undefined) {
                            miniGraph.setZoomLevel(savedData[key].zoomLevel);
                        }
                        
                        // Force immediate render with restored data
                        miniGraph.drawGraph();
                        
                        // Force resize after a short delay to ensure proper rendering
                        setTimeout(() => {
                            if (miniGraph.resizeCanvas) {
                                miniGraph.resizeCanvas();
                            }
                        }, 100);
                    }
                } else {
                    error(`Failed to create mini graph for ${key}`);
                }
            } else if (miniGraphData[key]) {
                debug(`Mini graph for ${key} already exists, preserving data`);
                // Mini graph already exists, just redraw it with existing data
                if (miniGraphData[key].drawGraph) {
                    miniGraphData[key].drawGraph();
                }
            } else {
                warn(`Canvas element for ${key} not found`); // Debug log
            }
        });
        
        debug('Mini graphs status:', Object.keys(miniGraphData)); // Debug log
        
        // Don't clear existing data - preserve it across tab switches
        if (Object.keys(miniGraphData).length > 0) {
            debug('Preserving existing mini graph data across tab switch');
        } else {
            debug('No existing mini graphs found, starting fresh');
        }
        
        // Set up periodic auto-save every 30 seconds
        setInterval(saveMiniGraphData, 30000);
        
        // Save data when page becomes hidden (switching tabs)
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                debug('Page hidden, saving mini-graph data');
                saveMiniGraphData();
            } else {
                debug('Page visible, checking for data updates');
                // Data will be restored from localStorage if available
            }
        });
        
        // Save data when page is about to unload
        window.addEventListener('beforeunload', function() {
            debug('Page unloading, saving mini-graph data');
            saveMiniGraphData();
        });
        
        // Force resize after a short delay to ensure CSS is applied
        setTimeout(() => {
            debug('Forcing mini-graph resize...');
            Object.keys(miniGraphData).forEach(key => {
                if (miniGraphData[key] && miniGraphData[key].resizeCanvas) {
                    miniGraphData[key].resizeCanvas();
                }
            });
        }, 100);
        
        // Additional resize after a longer delay to ensure all elements are properly rendered
        setTimeout(() => {
            debug('Second mini-graph resize to ensure proper heights...');
            Object.keys(miniGraphData).forEach(key => {
                if (miniGraphData[key] && miniGraphData[key].resizeCanvas) {
                    miniGraphData[key].resizeCanvas();
                }
            });
        }, 500);
        
        // Global resize handler for all mini-graphs
        window.addEventListener('resize', () => {
            debug('Window resized, updating all mini-graphs...');
            setTimeout(() => {
                Object.keys(miniGraphData).forEach(key => {
                    if (miniGraphData[key] && miniGraphData[key].resizeCanvas) {
                        miniGraphData[key].resizeCanvas();
                    }
                });
            }, 100);
        });
        
        // Function to force immediate rendering of all mini-graphs
        function forceRenderAllMiniGraphs() {
            debug('Forcing immediate render of all mini-graphs');
            Object.keys(miniGraphData).forEach(key => {
                if (miniGraphData[key]) {
                    if (miniGraphData[key].resizeCanvas) {
                        miniGraphData[key].resizeCanvas();
                    }
                    if (miniGraphData[key].drawGraph) {
                        miniGraphData[key].drawGraph();
                    }
                }
            });
        }
        
        // Force immediate render after a short delay
        setTimeout(forceRenderAllMiniGraphs, 200);
        
        // Also force render when page becomes visible
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                debug('Page became visible, forcing mini-graph render');
                setTimeout(forceRenderAllMiniGraphs, 100);
            }
        });
        
        debug('Mini graphs initialized with data persistence');
    });
    
            // Fallback initialization - try again when page is fully loaded
        window.addEventListener('load', function() {
            debug('Window load event fired'); // Debug log
            if (Object.keys(miniGraphData).length === 0) {
                debug('Mini graphs not initialized, trying again...'); // Debug log
                // Force re-initialization only if no graphs exist
                const canvasElements = {};
                
                // Only add sensors that are enabled and have canvas elements
                if (document.getElementById('mini-graph-dhw-1')) {
                    canvasElements['dhw-1'] = document.getElementById('mini-graph-dhw-1');
                }
                if (document.getElementById('mini-graph-heating-1')) {
                    canvasElements['heating-1'] = document.getElementById('mini-graph-heating-1');
                }
                if (document.getElementById('mini-graph-heating-2')) {
                    canvasElements['heating-2'] = document.getElementById('mini-graph-heating-2');
                }
                if (document.getElementById('mini-graph-bottom-1')) {
                    canvasElements['bottom-1'] = document.getElementById('mini-graph-bottom-1');
                }
                if (document.getElementById('mini-graph-bottom-2')) {
                    canvasElements['bottom-2'] = document.getElementById('mini-graph-bottom-2');
                }

                
                Object.keys(canvasElements).forEach(key => {
                    if (canvasElements[key] && !miniGraphData[key]) {
                        debug(`Creating mini graph for ${key} (fallback)`); // Debug log
                        if (key === 'dhw-1') {
                            miniGraphData[key] = createMiniGraph('mini-graph-' + key, '#ff6b6b', 0);
                        } else if (key.startsWith('heating')) {
                            const offset = key === 'heating-1' ? -5 : -10;
                            miniGraphData[key] = createMiniGraph('mini-graph-' + key, '#ffa500', offset);

                        } else if (key.startsWith('bottom')) {
                            const offset = key === 'bottom-1' ? -15 : -20;
                            miniGraphData[key] = createMiniGraph('mini-graph-' + key, '#4ecdc4', offset);
                        }
                    }
                });
                
                if (Object.keys(miniGraphData).length > 0) {
                    debug('Fallback initialization successful');
                }
            } else {
                debug('Mini graphs already exist, preserving data across tab switch');
                // Redraw existing graphs with their data
                Object.keys(miniGraphData).forEach(key => {
                    if (miniGraphData[key] && miniGraphData[key].drawGraph) {
                        miniGraphData[key].drawGraph();
                    }
                });
            }
        });
    
    // Function to update mini graphs with real data
    function updateMiniGraphs() {
        // Get current temperatures from enabled sensors only
        let dhwTemp = null;
        let dhwTemp2 = null;
        let dhwTemp3 = null;
        
        // Only try to get temperatures from elements that exist (enabled sensors)
        const dhwTempElement = document.getElementById('temp-0');
        if (dhwTempElement) {
            dhwTemp = parseFloat(dhwTempElement.textContent);
        }
        
        const dhwTemp2Element = document.getElementById('temp-1');
        if (dhwTemp2Element) {
            dhwTemp2 = parseFloat(dhwTemp2Element.textContent);
        }
        
        const dhwTemp3Element = document.getElementById('temp-2');
        if (dhwTemp3Element) {
            dhwTemp3 = parseFloat(dhwTemp3Element.textContent);
        }
        

        
        debug('updateMiniGraphs called, DHW temps:', dhwTemp, dhwTemp2, dhwTemp3); // Debug log
        
        // Update DHW Top mini graph - only if sensor is enabled
        if (!isNaN(dhwTemp) && miniGraphData['thermometer-0']) {
            debug('Updating thermometer-0 mini graph with:', dhwTemp); // Debug log
            miniGraphData['thermometer-0'].updateData(dhwTemp);
        }
        
        // Update DHW Middle mini graph - only if sensor is enabled
        if (!isNaN(dhwTemp2) && miniGraphData['thermometer-1']) {
            debug('Updating thermometer-1 mini graph with:', dhwTemp2); // Debug log
            miniGraphData['thermometer-1'].updateData(dhwTemp2);
        }
        
        // Update DHW Bottom mini graph - only if sensor is enabled
        if (!isNaN(dhwTemp3) && miniGraphData['thermometer-2']) {
            debug('Updating thermometer-2 mini graph with:', dhwTemp3); // Debug log
            miniGraphData['thermometer-2'].updateData(dhwTemp3);
        }
        

        
        // Update bottom graphs (still using calculated values for now) - only if DHW 1 is enabled
        if (!isNaN(dhwTemp)) {
            if (miniGraphData['thermometer-3']) {
                debug('Updating thermometer-3 mini graph with:', dhwTemp - 15); // Debug log
                miniGraphData['thermometer-3'].updateData(dhwTemp - 15);
            }
            if (miniGraphData['thermometer-4']) {
                debug('Updating thermometer-4 mini graph with:', dhwTemp - 20); // Debug log
                miniGraphData['thermometer-4'].updateData(dhwTemp - 20);
            }
        }
    }
    
    // Function to refresh mini graphs with current temperature data
    function refreshMiniGraphs() {
        debug('refreshMiniGraphs called - preserving existing data');
        
        // Don't clear existing data - just redraw with current data
        Object.keys(miniGraphData).forEach(key => {
            if (miniGraphData[key] && miniGraphData[key].drawGraph) {
                debug(`Redrawing ${key} mini graph with existing data`);
                miniGraphData[key].drawGraph();
            }
        });
        
        debug('Mini graphs refreshed while preserving data');
    }
    
    // Make functions globally available so they can be called from base template
    window.updateMiniGraphs = updateMiniGraphs;
    window.refreshMiniGraphs = refreshMiniGraphs;
    
    // Test function to manually add data to mini-graphs
    window.testMiniGraphData = function() {
        debug('Testing mini graph data flow...');
        
        // Get current DHW temperature from enabled sensors
        let dhwTemp = null;
        const dhwTempElement = document.getElementById('temp-0');
        if (dhwTempElement) {
            dhwTemp = parseFloat(dhwTempElement.textContent);
        }
        
        debug('Current DHW temp:', dhwTemp);
        
        if (!isNaN(dhwTemp)) {
            // Manually add data to each mini graph that exists
            Object.keys(miniGraphData).forEach(key => {
                if (miniGraphData[key]) {
                    debug(`Adding data to ${key} mini graph`);
                    miniGraphData[key].updateData(dhwTemp);
                }
            });
            debug('Data added to all mini graphs');
        } else {
            debug('DHW temperature not available, using test value 50');
            // Use test value if no real temperature
            Object.keys(miniGraphData).forEach(key => {
                if (miniGraphData[key]) {
                    debug(`Adding test data to ${key} mini graph`);
                    miniGraphData[key].updateData(50);
                }
            });
        }
    };
    
    // Function to check mini-graph dimensions
    window.checkMiniGraphDimensions = function() {
        debug('Checking mini-graph dimensions...');
        
        Object.keys(miniGraphData).forEach(key => {
            if (miniGraphData[key]) {
                const container = document.getElementById('mini-graph-' + key);
                const canvas = miniGraphData[key].canvas;
                
                debug(`${key}:`);
                debug(`  Container CSS width: ${getComputedStyle(container).width}`);
                debug(`  Container CSS height: ${getComputedStyle(container).height}`);
                debug(`  Canvas width: ${canvas.width}`);
                debug(`  Canvas height: ${canvas.height}`);
                debug(`  Container offsetWidth: ${container.offsetWidth}`);
                debug(`  Container offsetHeight: ${container.offsetHeight}`);
            }
        });
    };
    
    // Test function for debugging mini graphs
    function testMiniGraphs() {
        debug('Testing mini graphs...');
        debug('Available mini graphs:', Object.keys(miniGraphData));
        
        // Test with sample data
        const testTemp = 50;
        Object.keys(miniGraphData).forEach(key => {
            if (miniGraphData[key]) {
                debug(`Testing ${key} mini graph`);
                miniGraphData[key].updateData(testTemp);
            }
        });
        
        debug('Mini graph test completed');
    }
    
    // Make test function globally available
    window.testMiniGraphs = testMiniGraphs;
    
    // Manual initialization function
    window.initializeMiniGraphsManually = function() {
        debug('Manual initialization of mini graphs...');
        
        const canvasElements = {};
        
        // Only add sensors that are enabled and have canvas elements
        if (document.getElementById('mini-graph-dhw-1')) {
            canvasElements['dhw-1'] = document.getElementById('mini-graph-dhw-1');
        }
        if (document.getElementById('mini-graph-heating-1')) {
            canvasElements['heating-1'] = document.getElementById('mini-graph-heating-1');
        }
        if (document.getElementById('mini-graph-heating-2')) {
            canvasElements['heating-2'] = document.getElementById('mini-graph-heating-2');
        }
        if (document.getElementById('mini-graph-bottom-1')) {
            canvasElements['bottom-1'] = document.getElementById('mini-graph-bottom-1');
        }
        if (document.getElementById('mini-graph-bottom-2')) {
            canvasElements['bottom-2'] = document.getElementById('mini-graph-bottom-2');
        }

        
        debug('Canvas elements found:', canvasElements);
        
        // Clear existing mini graphs
        Object.keys(miniGraphData).forEach(key => {
            delete miniGraphData[key];
        });
        
        // Create new mini graphs
        Object.keys(canvasElements).forEach(key => {
            if (canvasElements[key]) {
                debug(`Creating mini graph for ${key}`);
                let miniGraph = null;
                
                if (key === 'dhw-1') {
                    miniGraph = createMiniGraph('mini-graph-' + key, '#ff6b6b', 0);
                } else if (key.startsWith('heating')) {
                    const offset = key === 'heating-1' ? -5 : -10;
                    miniGraph = createMiniGraph('mini-graph-' + key, '#ffa500', offset);

                } else if (key.startsWith('bottom')) {
                    const offset = key === 'bottom-1' ? -15 : -20;
                    miniGraph = createMiniGraph('mini-graph-' + key, '#4ecdc4', offset);
                }
                
                if (miniGraph) {
                    miniGraphData[key] = miniGraph;
                    info(`Mini graph for ${key} created successfully`);
                } else {
                    error(`Failed to create mini graph for ${key}`);
                }
            }
        });
        
        debug('Mini graphs created:', Object.keys(miniGraphData));
        
        // Populate with test data
        if (Object.keys(miniGraphData).length > 0) {
            // Start with empty graphs, no test data
            Object.keys(miniGraphData).forEach(key => {
                miniGraphData[key].clearData();
            });
            debug('Mini graphs cleared and ready for real data');
        }
        
        return Object.keys(miniGraphData);
    };
    
    // Additional debugging functions
    window.debugMiniGraph = function(graphName) {
        if (miniGraphData[graphName]) {
            debug(`Debugging ${graphName}:`, miniGraphData[graphName]);
            debug(`Canvas:`, miniGraphData[graphName].canvas);
            debug(`Data:`, miniGraphData[graphName].data);
            miniGraphData[graphName].drawTestPattern();
        } else {
            debug(`Mini graph ${graphName} not found. Available:`, Object.keys(miniGraphData));
        }
    };
    
    window.forceUpdateMiniGraph = function(graphName, temperature) {
        if (miniGraphData[graphName]) {
            debug(`Forcing update of ${graphName} with temperature ${temperature}`);
            miniGraphData[graphName].updateData(temperature);
        } else {
            debug(`Mini graph ${graphName} not found`);
        }
    };
    
    // Function to adjust thresholds with -1/+1 buttons
    function adjustThreshold(inputId, adjustment) {
        const input = document.getElementById(inputId);
        const currentValue = parseFloat(input.value);
        const newValue = currentValue + adjustment;
        
        // Apply min/max constraints
        if (inputId === 'dhw-low') {
            input.value = (Math.max(20, Math.min(70, newValue))).toFixed(1);
        } else if (inputId === 'dhw-high') {
            input.value = (Math.max(30, Math.min(80, newValue))).toFixed(1);
        } else if (inputId === 'hhw-low') {
            input.value = (Math.max(20, Math.min(70, newValue))).toFixed(1);
        } else if (inputId === 'hhw-high') {
            input.value = (Math.max(30, Math.min(80, newValue))).toFixed(1);
        }
    }
    
    // Function to ensure all threshold inputs show one decimal place
    function formatThresholdInputs() {
        const dhwLowInput = document.getElementById('dhw-low');
        const dhwHighInput = document.getElementById('dhw-high');
        const hhwLowInput = document.getElementById('hhw-low');
        const hhwHighInput = document.getElementById('hhw-high');

        
        if (dhwLowInput && dhwLowInput.value) {
            dhwLowInput.value = parseFloat(dhwLowInput.value).toFixed(1);
        }
        if (dhwHighInput && dhwHighInput.value) {
            dhwHighInput.value = parseFloat(dhwHighInput.value).toFixed(1);
        }
        if (hhwLowInput && hhwLowInput.value) {
            hhwLowInput.value = parseFloat(hhwLowInput.value).toFixed(1);
        }
        if (hhwHighInput && hhwHighInput.value) {
            hhwHighInput.value = parseFloat(hhwHighInput.value).toFixed(1);
        }

    }
    
    // Format threshold inputs when page loads
    document.addEventListener('DOMContentLoaded', function() {
        // Wait a bit for the template values to be rendered
        setTimeout(formatThresholdInputs, 100);
    });
    
    // Function to toggle mode
    async function toggleMode() {
        try {
            const response = await fetch('/control/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: 'action=toggle_mode'
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data.success) {
                    setTimeout(() => { location.reload(); }, 1000);
                }
            }
        } catch (error) {
            error('Error toggling mode:', error);
        }
    }

    // Function to sync relays
    async function syncRelays() {
        try {
            // This would typically call an API to sync relay states
            // For now, just reload the page to refresh status
            location.reload();
        } catch (error) {
            error('Error syncing relays:', error);
        }
    }
    
    // Function to cycle winter regime state
    async function cycleWinterRegime() {
        try {
            const response = await fetch('/control/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: 'action=cycle_winter_regime'
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data.success) {
                    // Update the button text and color to show new state
                    const winterBtn = document.getElementById('winter-toggle-btn');
                    if (winterBtn) {
                        const strongElement = winterBtn.querySelector('strong');
                        if (strongElement) {
                            strongElement.textContent = `Winter ${data.new_state.toUpperCase()}`;
                        }
                        
                        // Update button color based on new state
                        winterBtn.className = 'btn btn-control-heating w-100';
                        if (data.new_state === 'automatic') {
                            winterBtn.classList.add('btn-success');
                        } else if (data.new_state === 'off') {
                            winterBtn.classList.add('btn-danger');
                        } else {
                            winterBtn.classList.add('btn-primary');
                        }
                    }
                    
                    // Show success message
                    debug('Winter regime state changed:', data.message);
                } else {
                    error('Failed to cycle winter regime:', data.error);
                }
            } else {
                error('HTTP error cycling winter regime:', response.status);
            }
        } catch (error) {
            error('Error cycling winter regime:', error);
        }
    }
    
    // Timer management for independent device timers
    const timers = {
        furnace: {
            startTime: null,
            isRunning: false,
            interval: null,
            lastState: null // Track the last known state
        },
        pump: {
            startTime: null,
            isRunning: false,
            interval: null,
            lastState: null // Track the last known state
        }
    };

    function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        
        if (minutes < 60) {
            // Show mm:ss format when minutes < 60
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        } else {
            // Show hh:mm format when minutes >= 60
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
        }
    }

    function startTimer(device) {
        if (timers[device].interval) {
            clearInterval(timers[device].interval);
        }
        timers[device].startTime = Date.now();
        timers[device].isRunning = true;
        timers[device].interval = setInterval(() => {
            const elapsed = Math.floor((Date.now() - timers[device].startTime) / 1000);
            const timerElement = document.getElementById(`${device}-timer`);
            if (timerElement) {
                timerElement.textContent = formatTime(elapsed);
            }
        }, 1000);
        debug(`${device} timer started`);
    }

    function stopTimer(device) {
        if (timers[device].interval) {
            clearInterval(timers[device].interval);
            timers[device].interval = null;
        }
        timers[device].isRunning = false;
        const timerElement = document.getElementById(`${device}-timer`);
        if (timerElement) {
            timerElement.textContent = '00:00';
        }
        debug(`${device} timer stopped and reset`);
    }

    function resetTimer(device) {
        stopTimer(device);
        startTimer(device);
    }

    // Function to check if device state has changed and reset timer if needed
    function checkDeviceStateChange(device) {
        const deviceBtn = document.getElementById(`${device}-toggle-btn`);
        if (!deviceBtn) {
            debug(`${device} button not found, skipping state check`);
            return;
        }
        
        const currentState = deviceBtn.classList.contains('btn-success'); // true = ON, false = OFF
        
        // If this is the first check, just record the state
        if (timers[device].lastState === null) {
            debug(`${device} initial state check: ${currentState ? 'ON' : 'OFF'}`);
            timers[device].lastState = currentState;
            startTimer(device); // Start timer for initial state
            return;
        }
        
        // If state has changed, reset the timer
        if (timers[device].lastState !== currentState) {
            debug(`${device} state changed from ${timers[device].lastState ? 'ON' : 'OFF'} to ${currentState ? 'ON' : 'OFF'}, resetting ${device} timer only`);
            timers[device].lastState = currentState;
            resetTimer(device);
        }
    }

    // Function to toggle furnace
    async function toggleFurnace() {
        try {
            const furnaceBtn = document.getElementById('furnace-toggle-btn');
            const furnaceText = document.getElementById('furnace-toggle-text');
            const isCurrentlyRunning = furnaceBtn.classList.contains('btn-success');
            
            const action = isCurrentlyRunning ? 'manual_furnace_off' : 'manual_furnace_on';
            
            const response = await fetch('/control/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: `action=${action}`
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data.success) {
                    // Reset furnace timer immediately when button is clicked
                    debug('Furnace button clicked - resetting furnace timer only');
                    resetTimer('furnace');
                    timers.furnace.lastState = !isCurrentlyRunning;
                    
                    // Update button state
                    if (isCurrentlyRunning) {
                        furnaceBtn.className = 'btn btn-danger btn-control-furnace w-100 btn-timer-container';
                        furnaceText.textContent = 'Furnace OFF';
                    } else {
                        furnaceBtn.className = 'btn btn-success btn-control-furnace w-100 btn-timer-container';
                        furnaceText.textContent = 'Furnace ON';
                    }
                }
            }
        } catch (error) {
            error('Error toggling furnace:', error);
        }
    }
    
    // Function to toggle pump
    async function togglePump() {
        try {
            const pumpBtn = document.getElementById('pump-toggle-btn');
            const pumpText = document.getElementById('pump-toggle-text');
            const isCurrentlyRunning = pumpBtn.classList.contains('btn-success');
            
            const action = isCurrentlyRunning ? 'pump_off' : 'pump_on';
            
            const response = await fetch('/control/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: `action=${action}`
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data.success) {
                    // Reset pump timer immediately when button is clicked
                    debug('Pump button clicked - resetting pump timer only');
                    resetTimer('pump');
                    timers.pump.lastState = !isCurrentlyRunning;
                    
                    // Update button state
                    if (isCurrentlyRunning) {
                        pumpBtn.className = 'btn btn-danger btn-control-pump w-100 btn-timer-container';
                        pumpText.textContent = 'Pump OFF';
                    } else {
                        pumpBtn.className = 'btn btn-success btn-control-pump w-100 btn-timer-container';
                        pumpText.textContent = 'Pump ON';
                    }
                }
            }
        } catch (error) {
            error('Error toggling pump:', error);
        }
    }

    // Function to manually check device state changes (can be called from status updates)
    function checkDeviceStateChanges() {
        checkDeviceStateChange('furnace');
        checkDeviceStateChange('pump');
    }
    
    // Make the function globally available so it can be called from base.html
    window.checkDeviceStateChanges = checkDeviceStateChanges;
    
    // Function to initialize timers based on current device states
    function initializeTimers() {
        debug('Initializing independent device timers');
        
        // Check current states and start timers
        checkDeviceStateChange('furnace');
        checkDeviceStateChange('pump');
        
        // Set up frequent state checking to detect backend changes (every 2 seconds)
        setInterval(() => {
            checkDeviceStateChange('furnace');
            checkDeviceStateChange('pump');
        }, 2000);
    }
    
    // Initialize timers when page loads
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(initializeTimers, 500); // Small delay to ensure elements are loaded
    });
    
    // Helper function to get CSRF token
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    
    // Function to preserve mini-graph data across tab switches
    function preserveMiniGraphData() {
        debug('Preserving mini-graph data across tab switch');
        
        // Check if mini-graphs already exist and have data
        Object.keys(miniGraphData).forEach(key => {
            if (miniGraphData[key] && miniGraphData[key].data && miniGraphData[key].data.length > 0) {
                debug(`Preserving ${key} mini graph with ${miniGraphData[key].data.length} data points`);
                
                // Redraw the graph with existing data
                if (miniGraphData[key].drawGraph) {
                    miniGraphData[key].drawGraph();
                }
            }
        });
    }
    
    // Call this function when the page becomes visible (returning from another tab)
    document.addEventListener('visibilitychange', function() {
        if (!document.hidden) {
            debug('Page became visible, preserving mini-graph data');
            preserveMiniGraphData();
        }
    });
    
    // Also preserve data when the page is focused
    window.addEventListener('focus', function() {
        debug('Window focused, preserving mini-graph data');
        preserveMiniGraphData();
    });

    // Function to manually save mini-graph data (for debugging)
    window.saveMiniGraphDataNow = function() {
        debug('Manual save requested');
        saveMiniGraphData();
    };
    
    // Function to clear all mini-graph data (for debugging)
    window.clearAllMiniGraphData = function() {
        debug('Clearing all mini-graph data');
        Object.keys(miniGraphData).forEach(key => {
            if (miniGraphData[key]) {
                miniGraphData[key].clearData();
            }
        });
        localStorage.removeItem(MINI_GRAPH_STORAGE_KEY);
        localStorage.removeItem(MINI_GRAPH_TIMESTAMP_KEY);
        debug('All mini-graph data cleared');
    };
    
    // Function to show mini-graph data status (for debugging)
    window.showMiniGraphStatus = function() {
        debug('Mini-graph data status:');
        Object.keys(miniGraphData).forEach(key => {
            if (miniGraphData[key]) {
                const dataLength = miniGraphData[key].data.length;
                const maxBuffer = 131072;
                const percentage = (dataLength / maxBuffer * 100).toFixed(1);
                debug(`${key}: ${dataLength}/${maxBuffer} data points (${percentage}% full), zoom: ${miniGraphData[key].getZoomLevel()}x`);
            }
        });
        
        const savedData = localStorage.getItem(MINI_GRAPH_STORAGE_KEY);
        if (savedData) {
            const parsed = JSON.parse(savedData);
            debug('localStorage data summary:');
            Object.keys(parsed).forEach(key => {
                const dataLength = parsed[key].data ? parsed[key].data.length : 0;
                debug(`  ${key}: ${dataLength} points saved`);
            });
        } else {
            debug('No data in localStorage');
        }
    };

    // Function to manually test data plotting (for debugging)
    window.testDataPlotting = function() {
        debug('Testing data plotting...');
        Object.keys(miniGraphData).forEach(key => {
            if (miniGraphData[key]) {
                debug(`${key}: ${miniGraphData[key].data.length} data points`);
                if (miniGraphData[key].data.length > 0) {
                    debug(`${key} data:`, miniGraphData[key].data.slice(-5)); // Last 5 points
                }
                if (miniGraphData[key].drawGraph) {
                    debug(`Drawing ${key} graph...`);
                    miniGraphData[key].drawGraph();
                }
            }
        });
    };
    
    // Function to add test data to all graphs (for debugging)
    window.addTestData = function() {
        debug('Adding test data to all graphs...');
        const testTemp = 50;
        Object.keys(miniGraphData).forEach(key => {
            if (miniGraphData[key]) {
                debug(`Adding test data to ${key}`);
                miniGraphData[key].updateData(testTemp);
            }
        });
        debug('Test data added to all available mini graphs');
    };
</script>
{% endblock %}